#!/usr/bin/env python

import os

FIXTURE_ROOT = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'fixtures/concolic/')

import sys
import re
import unittest
import inspect

from harness.artemis import execute_artemis, to_appropriate_type
from harness.artemis import OUTPUT_DIR as ARTEMIS_OUTPUT_DIR
from harness.js_injection_server import start_server_with_js_injections
from harness.js_injection_server import HOST_NAME as INJECTION_SERVER_HOST
from harness.js_injection_server import PORT as INJECTION_SERVER_PORT
from os import listdir
from os.path import isfile, join


class Concolic(unittest.TestCase):
    pass

def list_tests_in_folder(folder):
    out = []

    for f in listdir(folder):
        p = join(folder, f)
        if not isfile(p) or f[0:1] == "_" or f[0:1] == "%" or not f[-5:] == '.html':
            continue
        result = {"test": {}, "i_test": {}, "fn": f, "expected_failure": False}
        with open(p, 'r') as fl:
            if re.match("^\s*<!--\s*$", fl.readline()):
                for line in fl:
                    ef = re.match("^\s*EXPECTED_FAILURE", line)
                    if ef:
                        result["expected_failure"] = True
                        continue
                    m = re.match("\s*TEST(_INTERN)? ([^<>!=\s]+)\s*((<|>|=|!)=?)([^=].*)$", line)
                    if not m:
                        continue
                    test_mode = "i_test" if m.group(1) else "test"
                    op = {"<": "lt", "<=": "leq", ">": "gt", ">=": "geq", "==": "eq", "=": "eq", "!": "neq",
                          "!=": "neq"}[m.group(3)]
                    if op not in result[test_mode]:
                        result[test_mode][op] = {}
                    result[test_mode][op][m.group(2).strip()] = m.group(5).strip()
                    if re.match("-->", line):
                        break

        if len(result['test']) == 0:
            result['test'] = None
        if len(result['i_test']) == 0:
            result['i_test'] = None
        out.append(result)
    return out

def _assert_test_case(test_case, op, v1, v2):
    if op == "eq":
        test_case.assertEqual(v1, v2)
    elif op == "neq":
        test_case.assertNotEqual(v1, v2)
    elif op == "geq":
        test_case.assertGreaterEqual(v1, v2)
    elif op == "gt":
        test_case.assertGreater(v1, v2)
    elif op == "leq":
        test_case.assertLessEqual(v1, v2)
    elif op == "lt":
        test_case.assertLess(v1, v2)

def _get_from_report(report, key):
    m = re.match('PC(\[([0-9]+)\])?', key)
    if m:
        index = int(m.group(2)) if m.group(2) else 0
        pc = report['pathCondition']
        assert len(pc) >= index + 1, "Not enough path conditions generated by artemis"
        return {"val": pc[index].replace(" ", ""), "pc": True}
    else:
        assert key in report, "Could not test for %s. Index not found in report" % key
        return {"val": report[key], "pc": False}


def test_generator(artemis_runner, full_filename, name, test_dict=None, internal_test=None):
    def test(self):
        report = artemis_runner(name, full_filename)

        assert test_dict or internal_test, "No tests to execute"
        tested_unsat = False
        tested_not_written = False
        tested_not_solved = False
        tested_no_failed_injections = False

        if internal_test:
            for op, tMap in internal_test.iteritems():
                for s, v in tMap.iteritems():
                    tested_not_written = tested_not_written or s == "Concolic::Solver::ConstraintsNotWritten"
                    tested_unsat = tested_unsat or s == "Concolic::Solver::ConstraintsSolvedAsUNSAT"
                    tested_not_solved = tested_not_solved or s == "Concolic::Solver::ConstraintsNotSolved"
                    tested_no_failed_injections = tested_no_failed_injections or s == "Concolic::FailedInjections"
                    _assert_test_case(self, op, _get_from_report(report, s)['val'], _get_from_report(report, v)['val'])

        if test_dict:
            for op, tMap in test_dict.iteritems():
                for s, v in tMap.iteritems():
                    tested_not_written = tested_not_written or s == "Concolic::Solver::ConstraintsNotWritten"
                    tested_unsat = tested_unsat or s == "Concolic::Solver::ConstraintsSolvedAsUNSAT"
                    tested_not_solved = tested_not_solved or s == "Concolic::Solver::ConstraintsNotSolved"
                    tested_no_failed_injections = tested_no_failed_injections or s == "Concolic::FailedInjections"

                    v = to_appropriate_type(s, v)
                    r_val = _get_from_report(report, s)
                    _assert_test_case(self, op, r_val['val'], v.replace(" ", "") if r_val['pc'] else v)

        assert tested_unsat or not "Concolic::Solver::ConstraintsSolvedAsUNSAT" in report, \
            "Constraints solved as UNSAT are errors pr. default."
        assert tested_not_written or not "Concolic::Solver::ConstraintsNotWritten" in report, \
            "Not written constraints are pr. default an error"
        assert tested_not_solved or not "Concolic::Solver::ConstraintsNotSolved" in report, \
            "Not solved constraints are a pr. default an error."
        assert tested_no_failed_injections or not "Concolic::FailedInjections" in report, \
            "Failed injections are an error by default."

    return test


def _artemis_runner(name, path):
    return execute_artemis(name, path,
                           iterations=0,
                           debug_concolic=' ',
                           major_mode='concolic',
                           concolic_event_sequences='simple',
                           #concolic_search_procedure='dfs-testing',
                           verbose=True)


def setup_concolic_tests():

    for t in list_tests_in_folder(FIXTURE_ROOT):
        test_name = 'test_%s' % t['fn'].replace(".", "_")
        file_name = "%s%s" % (FIXTURE_ROOT, t['fn'])
        
        test = test_generator(_artemis_runner, file_name, test_name, test_dict=t['test'], internal_test=t['i_test'])
        if t['expected_failure']:
            test = unittest.expectedFailure(test)
        
        setattr(Concolic, test_name, test)





class ConcolicTraceDivergenceTests(unittest.TestCase):
    def run_artemis_and_get_final_graph(self, name):
        address = "http://" + INJECTION_SERVER_HOST + ":" + str(INJECTION_SERVER_PORT)
        report = _artemis_runner(name, address)
        
        # Find the latest tree dump in the output directory.
        output_dir = os.path.join(ARTEMIS_OUTPUT_DIR, name)
        
        all_tree_files = [x for x in os.listdir(output_dir) if os.path.isfile(os.path.join(output_dir, x)) and x.startswith("tree-")]
        
        if not all_tree_files:
            return None
        
        # There is expected to only be one entry anyway.
        latest_tree_file = sorted(all_tree_files)[-1]
        
        with open(os.path.join(output_dir, latest_tree_file)) as f:
            full_graph = f.readlines()
        
        # Filter out only the interesting part of the graph
        result = [edge.rstrip() for edge in full_graph if "->" in edge]
        return result
    
    def test_divergent_from_root(self):
        
        js1 = "var x = document.getElementById('testinput'); if (x.value == 'testme') { return true; } else { alert('Error'); return false; }"
        
        js2 = "alert('Wasn't expecting that!');"
        
        start_server_with_js_injections([js1, js2, js1])
        
        #import time
        #time.sleep(1000)
        
        graph = self.run_artemis_and_get_final_graph(inspect.currentframe().f_code.co_name)
        
        self.assertIsNotNone(graph)
        
        # TODO: Expect this to be a diverged tree, but in fact there is no branch at all...
        expected_graph = """
  start -> marker_0 [xlabel = "1"];
  marker_0 -> marker_1;
  marker_1 -> aggr_2;
  aggr_2 -> load_3;
  load_3 -> end_s_4;""".split("\n")[1:]
        
        self.assertEqual(graph, expected_graph)












if __name__ == '__main__':
    setup_concolic_tests()
    unittest.main(buffer=True, catchbreak=True)

